v1ç‰ˆæœ¬ä¸»è¦çš„ä½œç”¨æ˜¯å¿«é€ŸåŸå‹å¼€å‘ã€‚
åœ¨è¿™ä¸ªé˜¶æ®µä¼šç”¨åˆ°ä¸€äº›åé¢ä¸ç”¨çš„æŠ€æœ¯ï¼Œè¿™äº›æŠ€æœ¯ä¸»è¦ä¸ºäº†å®¢æˆ·è¿›è¡Œä¿¡æ¯çš„å±•ç¤ºä½¿ç”¨ã€‚
åŸå‹å¼€å‘ã€‚

1. ä¿®æ”¹requirements.txtï¼Œæ·»åŠ 
python-multipart==0.0.20
aiofiles==24.1.0
streamlit==1.40.2
ä¹‹å
pip install -U -r requirements.txt


2. æ‰“å¼€app/ingestion/loader.pyï¼Œåœ¨æ–‡ä»¶æœ€åº•éƒ¨è¿½åŠ ä¸‹é¢ä»£ç ï¼š
ç¬¬ä¸€ä¸ªå‡½æ•°ä¸»è¦æ˜¯ä¸ºäº†åº”å¯¹åç»­æ–‡ä»¶å•ç‹¬è¿½åŠ è€Œè®¾è®¡çš„ï¼Œä»–å°±æ˜¯å¤„ç†ä¸€ä¸ªå•ç‹¬çš„æ–‡ä»¶è€Œå·²ã€‚
def load_single_file(path: Path) -> List[Document]:
    """æ ¹æ®æ–‡ä»¶åç¼€åŠ è½½æ–‡ä»¶ï¼Œè¿”å›LangChainçš„ Documentåˆ—è¡¨"""
    suf = path.suffix.lower()
    if suf == ".pdf":
        return load_pdf(path)
    if suf in [".docx", ".doc"]:
        return load_docx(path)
    if suf in [".md", ".txt"]:
        text = path.read_text(encoding="utf-8")
        return [Document(page_content=text, metadata={"source": str(path)})] if text.strip() else []
    return []

ç¬¬äºŒä¸ªå‡½æ•°ä¸»è¦æ˜¯æŠŠä¸€æ‰¹Documentåˆ‡æˆå°å—ï¼Œå¹¶ä¸”ç»™æ¯ä¸€å°å—è´´ä¸Šæƒé™æ ‡ç­¾visibilityå’Œæ–‡æ¡£IDã€‚
def split_with_visibility(docs: List[Document], visibility: str, doc_id: str | None = None) -> List[Document]:
    chunks = split_docs(docs)
    for c in chunks:
        c.metadata = dict(c.metadata or {})
        c.metadata["visibility"] = visibility
        if doc_id:
            c.metadata["doc_id"] = doc_id
    return chunks



3. app/main.pyæ•´ä¸ªè¦†ç›–æˆä¸‹é¢è¿™ä¸ªï¼ˆæ–°å¢/ingestå’Œ/reindexï¼‰
from __future__ import annotations

æ·»åŠ å¦‚ä¸‹ä¾èµ–
from app.deps import get_vs, get_embeddings
from app.ingestion.loader import load_single_file, split_with_visibility, load_docs, split_docs
from app.config import settings
import time
import uuid
from pathlib import Path
from typing import Optional
import chromadb

ä¿®æ”¹
from fastapi import FastAPI
ä¸º
from fastapi import FastAPI, UploadFile, File, Form, HTTPException

æ·»åŠ 
DATA_DOCS_DIR = Path("./data/docs")
DATA_DOCS_DIR.mkdir(parents=True, exist_ok=True)

@app.post("/ingest")
async def ingest(
    file: UploadFile = File(...),
    visibility: str = Form("public"),
    doc_id: Optional[str] = Form(None)):

    if not file.filename:
        raise HTTPException(status_code=400, detail="Empty filename")

    visibility = (visibility or "public").strip().lower()

    suffix = Path(file.filename).suffix
    safe_name = f"{int(time.time())}_{uuid.uuid4().hex}{suffix}"
    save_path = DATA_DOCS_DIR / safe_name

    content = await file.read()
    if not content:
        raise HTTPException(status_code=400, detail="Empty file")
    save_path.write_bytes(content)

    docs = load_single_file(save_path)
    if not docs:
        raise HTTPException(status_code=400, detail=f"Unsupported or empty file type: {suffix}")

    chunks = split_with_visibility(docs, visibility=visibility, doc_id=doc_id)

    vs = get_vs()
    vs.add_documents(chunks)

    return {
        "saved_as": str(save_path),
        "visibility": visibility,
        "doc_id": doc_id,
        "chunks": len(chunks),
    }


@app.post("/reindex")
def reindex(visibility_default: str = Form("public")):
    visibility_default = (visibility_default or "public").strip().lower()

    client = chromadb.HttpClient(host=settings.chroma_host, port=settings.chroma_port)
    try:
        client.delete_collection(settings.collection_name)
    except Exception:
        print('================åˆ é™¤chromadbæŠ¥é”™äº†')
    client.get_or_create_collection(settings.collection_name)

    vs = get_vs()
    raw_docs = load_docs(str(DATA_DOCS_DIR))
    if not raw_docs:
        return {"chunks": 0, "docs": 0, "message": "No documents found in data/docs"}

    chunks = split_docs(raw_docs)
    for c in chunks:
        c.metadata = dict(c.metadata or {})
        c.metadata.setdefault("visibility", visibility_default)

    vs.add_documents(chunks)

    return {"docs": len(raw_docs), "chunks": len(chunks), "visibility_default": visibility_default}


@app.get("/")
def root():
    return {"status": "ok", "docs": "/docs"}

ä¸‹é¢æ˜¯è¿è¡Œå’Œæµ‹è¯•
uvicorn app.main:app --reload --port 8002
æµ‹è¯•
curl -X POST "http://127.0.0.1:8002/ingest" \
  -F "file=@./data/docs/åˆ¶åº¦ç¤ºä¾‹1_å‘˜å·¥å¹´å‡ä¸è¯·å‡ç®¡ç†åŠæ³•.docx" \
  -F "visibility=public"

å¦‚æœè¦å®éªŒï¼Œå¦ä¸€è¾¹çš„åŒå­¦ç”µè„‘è¿è¡Œè¿™ä¸ªé¡¹ç›®å³å¯ï¼Œä½ è‡ªå·±è¿™è¾¹ä»€ä¹ˆéƒ½ä¸ç”¨å¼€ã€‚
pycharméƒ½ä¸ç”¨æ‰“å¼€ï¼Œç›´æ¥ç”¨curlå‘½ä»¤å°±å¯ä»¥äº†ã€‚

çœ‹åˆ°ç±»ä¼¼ï¼Œæ­£ç¡®
{"saved_as":"data/docs/1763797854_41837761cfd74278adaa786b39b33746.docx","visibility":"public","doc_id":null,"chunks":1}

å¦‚æœéœ€è¦å…¨é‡é‡å»ºï¼š
curl -X POST "http://127.0.0.1:8002/reindex" -F "visibility_default=public"


4. ui/streamlit_app.py
Streamlitæ˜¯ä¸€ä¸ªç”¨Pythonå¿«é€Ÿåšç½‘é¡µç•Œé¢çš„æ¡†æ¶ï¼Œä¸“é—¨ç»™æ•°æ®ç§‘å­¦ã€AI demoã€åŸå‹ç”¨çš„ã€‚
å†™å‡ è¡ŒPythonå°±èƒ½ç«‹åˆ»æœ‰ä¸€ä¸ªå¸¦æŒ‰é’®ã€è¾“å…¥æ¡†ã€å›¾è¡¨çš„ç½‘é¡µï¼Œä¸ç”¨å†™HTML/CSS/JSã€‚
æˆ‘ä»¬è¿™é‡Œå°±æ˜¯ç©ä¸€ä¸‹ï¼Œæ‡’å¾—æå‰ç«¯äº†ï¼Œç”¨ä¸€ä¸ªç½‘é¡µæµ‹è¯•ä¸€ä¸‹ã€‚
ä¸‹é¢éƒ½æ˜¯AIå†™æˆï¼Œæ— éœ€è®°å¿†ï¼Œä¸ç”¨èƒŒï¼Œä¸ç”¨ç®¡ï¼Œåé¢ä¼šç”¨å…¶å®ƒä¸“ä¸šä¸€ç‚¹çš„å‰ç«¯æ¡†æ¶ã€‚

import streamlit as st
import requests

API_BASE = "http://127.0.0.1:8002"

st.set_page_config(page_title="Enterprise KB Assistant", layout="wide")

# ---- deep blue modern theme ----
st.markdown(
    """
    <style>
    .stApp {
        background: radial-gradient(1200px circle at 10% 0%, #0b2a5b 0%, #06162f 45%, #040b19 100%);
        color: #e6eefc;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    .block-container { padding-top: 2rem; }
    h1, h2, h3, h4 { color: #e6eefc; }
    .card {
        background: rgba(8, 22, 48, 0.85);
        border: 1px solid rgba(120,160,220,0.25);
        border-radius: 16px;
        padding: 16px 18px;
        box-shadow: 0 8px 30px rgba(0,0,0,0.35);
    }
    .small { color: #b9c8e6; font-size: 0.9rem; }
    </style>
    """,
    unsafe_allow_html=True,
)

st.markdown("<h1>ğŸ¢ Enterprise Knowledge Assistant</h1>", unsafe_allow_html=True)
st.markdown('<div class="small">Upload policies / ask questions / see citations.</div>', unsafe_allow_html=True)
st.write("")

col1, col2 = st.columns([0.38, 0.62], gap="large")

with col1:
    st.markdown('<div class="card">', unsafe_allow_html=True)
    st.subheader("ğŸ“ æ–‡æ¡£ä¸Šä¼ å…¥åº“")
    uploaded = st.file_uploader("é€‰æ‹© Word/PDF/MD/TXT", type=["pdf","docx","doc","md","txt"])
    visibility = st.selectbox("å¯è§æ€§", ["public", "hr", "finance", "it"], index=0)
    doc_id = st.text_input("doc_idï¼ˆå¯é€‰ï¼‰", "")
    if st.button("ä¸Šä¼ å¹¶å…¥åº“", use_container_width=True, type="primary") and uploaded:
        files = {"file": (uploaded.name, uploaded.getvalue())}
        data = {"visibility": visibility}
        if doc_id.strip():
            data["doc_id"] = doc_id.strip()
        r = requests.post(f"{API_BASE}/ingest", files=files, data=data, timeout=120)
        if r.ok:
            st.success(f"å…¥åº“æˆåŠŸï¼šchunks={r.json().get('chunks')}")
        else:
            st.error(r.text)
    st.write("")
    if st.button("å…¨é‡é‡å»ºï¼ˆæ¸…åº“+é‡å»ºï¼‰", use_container_width=True):
        r = requests.post(f"{API_BASE}/reindex", data={"visibility_default": "public"}, timeout=300)
        if r.ok:
            st.success(f"é‡å»ºå®Œæˆï¼šchunks={r.json().get('chunks')}")
        else:
            st.error(r.text)
    st.markdown('</div>', unsafe_allow_html=True)

with col2:
    st.markdown('<div class="card">', unsafe_allow_html=True)
    st.subheader("ğŸ’¬ ä¼ä¸šçŸ¥è¯†é—®ç­”")
    q = st.text_area("è¾“å…¥ä½ çš„é—®é¢˜", height=120, placeholder="ä¾‹å¦‚ï¼šå¹´å‡éœ€è¦æå‰å¤šä¹…ç”³è¯·ï¼Ÿ")
    role = st.selectbox("ä½ çš„è§’è‰²", ["public", "hr", "finance", "it_admin", "manager"], index=0)
    if st.button("å‘é€", use_container_width=True) and q.strip():
        payload = {"text": q.strip(), "user_role": role, "requester": "streamlit"}
        r = requests.post(f"{API_BASE}/chat", json=payload, timeout=120)
        if r.ok:
            st.markdown("**å›ç­”ï¼š**")
            st.write(r.json()["answer"])
        else:
            st.error(r.text)
    st.markdown('</div>', unsafe_allow_html=True)


ä¹‹åæµ‹è¯•ï¼š
streamlit run ui/streamlit_app.py

è¿è¡Œå’Œæµ‹è¯•å‰ç«¯çš„å‰ææ¡ä»¶æ˜¯ç”¨curlæˆ–è€…postmanç­‰å…ˆå¯¹åå°åšäº†å®Œç¾çš„æµ‹è¯•æ‰å¯ä»¥ã€‚
â€¼ï¸åå°ä¸æ­£ç¡®ï¼Œæ€»ç»“æœä¸€å®šä¸æ­£ç¡®ï¼Œä¸ç®¡ä½ åŠ ä¸åŠ å‰ç«¯
â€¼ï¸åå°æ­£ç¡®ï¼Œä¹Ÿä¸èƒ½ä¿è¯åŠ äº†å‰ç«¯åä¸€å®šæ­£ç¡®



